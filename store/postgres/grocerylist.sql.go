// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.25.0
// source: grocerylist.sql

package postgres

import (
	"context"
	"encoding/json"

	"github.com/google/uuid"
)

const createGrocerylist = `-- name: CreateGrocerylist :one
INSERT INTO grocerylists (id, menu_id, household_id, createdat, createdby)
VALUES ($1, $2, $3, now(), $4)
RETURNING id, createdat, createdby, menu_id, household_id, archived
`

type CreateGrocerylistParams struct {
	ID          uuid.UUID
	MenuID      uuid.NullUUID
	HouseholdID uuid.NullUUID
	Createdby   uuid.UUID
}

func (q *Queries) CreateGrocerylist(ctx context.Context, arg CreateGrocerylistParams) (Grocerylist, error) {
	row := q.db.QueryRowContext(ctx, createGrocerylist,
		arg.ID,
		arg.MenuID,
		arg.HouseholdID,
		arg.Createdby,
	)
	var i Grocerylist
	err := row.Scan(
		&i.ID,
		&i.Createdat,
		&i.Createdby,
		&i.MenuID,
		&i.HouseholdID,
		&i.Archived,
	)
	return i, err
}

const getGrocerylistById = `-- name: GetGrocerylistById :one
SELECT id, createdat, createdby, menu_id, household_id, archived FROM grocerylists WHERE id = $1
`

func (q *Queries) GetGrocerylistById(ctx context.Context, id uuid.UUID) (Grocerylist, error) {
	row := q.db.QueryRowContext(ctx, getGrocerylistById, id)
	var i Grocerylist
	err := row.Scan(
		&i.ID,
		&i.Createdat,
		&i.Createdby,
		&i.MenuID,
		&i.HouseholdID,
		&i.Archived,
	)
	return i, err
}

const getGrocerylistWithItemsByHouseholdId = `-- name: GetGrocerylistWithItemsByHouseholdId :one
SELECT
  gl.id AS grocerylist_id,
  gl.household_id,
  gl.menu_id,
  gl.createdby,
  COALESCE(
      JSON_AGG(
          JSON_BUILD_OBJECT(
              'item_id', i.id,
              'check', i.check,
              'name', ing.name
          ) ORDER BY ing.name ASC
      ) FILTER (WHERE i.id IS NOT NULL),
      '[]'::json
  )::json AS items
FROM
  grocerylists gl
LEFT JOIN
  items i ON i.grocerylist_id = gl.id
LEFT JOIN
  ingredients ing ON ing.id = i.ingredient_id
WHERE
  gl.household_id = $1
GROUP BY
  gl.id
ORDER BY
  gl.createdat DESC
LIMIT 1
`

type GetGrocerylistWithItemsByHouseholdIdRow struct {
	GrocerylistID uuid.UUID
	HouseholdID   uuid.NullUUID
	MenuID        uuid.NullUUID
	Createdby     uuid.UUID
	Items         json.RawMessage
}

func (q *Queries) GetGrocerylistWithItemsByHouseholdId(ctx context.Context, householdID uuid.NullUUID) (GetGrocerylistWithItemsByHouseholdIdRow, error) {
	row := q.db.QueryRowContext(ctx, getGrocerylistWithItemsByHouseholdId, householdID)
	var i GetGrocerylistWithItemsByHouseholdIdRow
	err := row.Scan(
		&i.GrocerylistID,
		&i.HouseholdID,
		&i.MenuID,
		&i.Createdby,
		&i.Items,
	)
	return i, err
}

const getGrocerylistWithItemsById = `-- name: GetGrocerylistWithItemsById :one
SELECT
  gl.id AS grocerylist_id,
  gl.household_id,
  gl.menu_id,
  JSON_AGG(
    JSON_BUILD_OBJECT(
      'item_id', i.id,
      'check', i.check,
      'name', ing.name 
    )
  ) AS items
FROM
  grocerylists gl
LEFT JOIN
  items i ON i.grocerylist_id = gl.id
LEFT JOIN
  ingredients ing ON ing.id = i.ingredient_id
WHERE
  gl.id = $1
GROUP BY
  gl.id
`

type GetGrocerylistWithItemsByIdRow struct {
	GrocerylistID uuid.UUID
	HouseholdID   uuid.NullUUID
	MenuID        uuid.NullUUID
	Items         json.RawMessage
}

func (q *Queries) GetGrocerylistWithItemsById(ctx context.Context, id uuid.UUID) (GetGrocerylistWithItemsByIdRow, error) {
	row := q.db.QueryRowContext(ctx, getGrocerylistWithItemsById, id)
	var i GetGrocerylistWithItemsByIdRow
	err := row.Scan(
		&i.GrocerylistID,
		&i.HouseholdID,
		&i.MenuID,
		&i.Items,
	)
	return i, err
}

const getGrocerylistWithItemsByUserId = `-- name: GetGrocerylistWithItemsByUserId :one
SELECT
  gl.id AS grocerylist_id,
  gl.household_id,
  gl.menu_id,
  gl.createdby,
  COALESCE(
    JSON_AGG(
        JSON_BUILD_OBJECT(
          'item_id', i.id,
          'check', i.check,
          'name', ing.name
      ) ORDER BY ing.name ASC
    ) FILTER (WHERE i.id IS NOT NULL),
    '[]'::json
  )::json AS items
FROM
  grocerylists gl
LEFT JOIN
  items i ON i.grocerylist_id = gl.id
LEFT JOIN
  ingredients ing ON ing.id = i.ingredient_id
WHERE
  gl.createdby = $1
AND
    gl.archived = false
GROUP BY
  gl.id
ORDER BY
  gl.createdat DESC
LIMIT 1
`

type GetGrocerylistWithItemsByUserIdRow struct {
	GrocerylistID uuid.UUID
	HouseholdID   uuid.NullUUID
	MenuID        uuid.NullUUID
	Createdby     uuid.UUID
	Items         json.RawMessage
}

func (q *Queries) GetGrocerylistWithItemsByUserId(ctx context.Context, createdby uuid.UUID) (GetGrocerylistWithItemsByUserIdRow, error) {
	row := q.db.QueryRowContext(ctx, getGrocerylistWithItemsByUserId, createdby)
	var i GetGrocerylistWithItemsByUserIdRow
	err := row.Scan(
		&i.GrocerylistID,
		&i.HouseholdID,
		&i.MenuID,
		&i.Createdby,
		&i.Items,
	)
	return i, err
}

const getGrocerylists = `-- name: GetGrocerylists :many
SELECT id, createdat, createdby, menu_id, household_id, archived FROM grocerylists
`

func (q *Queries) GetGrocerylists(ctx context.Context) ([]Grocerylist, error) {
	rows, err := q.db.QueryContext(ctx, getGrocerylists)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Grocerylist
	for rows.Next() {
		var i Grocerylist
		if err := rows.Scan(
			&i.ID,
			&i.Createdat,
			&i.Createdby,
			&i.MenuID,
			&i.HouseholdID,
			&i.Archived,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getLatestGrocerylist = `-- name: GetLatestGrocerylist :one
SELECT id, createdat, createdby, menu_id, household_id, archived FROM grocerylists ORDER BY createdat DESC LIMIT 1
`

func (q *Queries) GetLatestGrocerylist(ctx context.Context) (Grocerylist, error) {
	row := q.db.QueryRowContext(ctx, getLatestGrocerylist)
	var i Grocerylist
	err := row.Scan(
		&i.ID,
		&i.Createdat,
		&i.Createdby,
		&i.MenuID,
		&i.HouseholdID,
		&i.Archived,
	)
	return i, err
}
